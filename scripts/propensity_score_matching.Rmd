---
title: "Tract Matching"
output: html_document
---
# Prep
## Imports
```{r}
library(dplyr)
```

## Pull city data sources
```{r}
BOS_data_raw = read.csv("../../local/BOS_data_census.tsv", sep = "\t")
CHI_data_raw = read.csv("../../local/CHI_data_census.tsv", sep = "\t")
SFO_data_raw = read.csv("../../local/SFO_data_census.tsv", sep = "\t")
```

## Convert datetime columns to POSIXct
```{r}
BOS_data_raw$req_dt <- as.POSIXct(BOS_data_raw$req_dt,
            format = "%Y-%m-%dT%H:%M:%SZ",
            tz = "America/New_York")
CHI_data_raw$req_dt <- as.POSIXct(CHI_data_raw$req_dt,
            format = "%Y-%m-%dT%H:%M:%SZ",
            tz = "America/Chicago")
SFO_data_raw$req_dt <- as.POSIXct(SFO_data_raw$req_dt,
            format = "%Y-%m-%dT%H:%M:%SZ",
            tz = "America/Los_Angeles")

BOS_data_raw$updt_dt <- as.POSIXct(BOS_data_raw$updt_dt,
            format = "%Y-%m-%dT%H:%M:%SZ",
            tz = "America/New_York")
CHI_data_raw$updt_dt <- as.POSIXct(CHI_data_raw$updt_dt,
            format = "%Y-%m-%dT%H:%M:%SZ",
            tz = "America/Chicago")
SFO_data_raw$updt_dt <- as.POSIXct(SFO_data_raw$updt_dt,
            format = "%Y-%m-%dT%H:%M:%SZ",
            tz = "America/Los_Angeles")
```

## Combine city data sources
```{r}
df_311_census <- dplyr::bind_rows(BOS_data_raw, CHI_data_raw, SFO_data_raw)
```

## Clear city data sources
```{r}
rm(BOS_data_raw, CHI_data_raw, SFO_data_raw)
```

## Remove any unneccesarry columns
```{r}
df_311_census <- subset(df_311_census, select = -c(address))
```

## Convert non-numeric columns to factors
```{r}
cols_to_convert_to_factor <- c("city", "status", "srvc_nm", "geoid", "detail", "st_fip", "cty_fip", "trt_fip", "state", "req_aim", "illegal", "adv", "topic")
df_311_census[cols_to_convert_to_factor] <- lapply(df_311_census[cols_to_convert_to_factor], as.factor)
```

## Summarize full city data
```{r}
summary(df_311_census)
```

## Filter out tracts with n <= 30 data points
```{r}
(nrow(df_311_census))
df_311_census <- df_311_census %>%
  group_by(geoid) %>%
  filter(n() > 30)
(nrow(df_311_census))
```

## Filter out tracts with no pop_nw data
```{r}
(nrow(df_311_census))
df_311_census <- na.omit(df_311_census, cols="pop_nw")
(nrow(df_311_census))
```

### Define treatment as 60%+ non-white tract (nw_60pct)
```{r}
nw_threshold = 0.60

df_311_census <- df_311_census %>%
  mutate(nw_60pct = ifelse(pop_nw >= nw_threshold, 1, 0))
```

```{r}
(df_311_census %>%
    group_by(city) %>%
    count(nw_60pct))
```

## Find 311 requests per month

```{r}
library(lubridate)
df_311_census$req_dt <- as.Date(df_311_census$req_dt)
df_311_census$updt_dt <- as.Date(df_311_census$updt_dt)
```

```{r}
df_311_monthly_full <- df_311_census %>%
  group_by(month=floor_date(req_dt, "month")) %>%
  count(geoid)

#TODO: remove first 2 months - limit to certain range, e.g. 2008-2014? by city?

avg_mon_reqs <- aggregate(df_311_monthly_full$n, by=list(geoid=df_311_monthly_full$geoid), mean)
```

```{r}
population_totals <- cbind.data.frame("geoid" = df_311_census$geoid, "pop_tot" = df_311_census$pop_tot)

joined_mon_reqs_and_pop_tot <- avg_mon_reqs %>%
  left_join(population_totals) %>%
  distinct() %>%
  mutate(reqs_per_mon_per_1k = 1000 * (x / pop_tot))
```

# Filter out Nov 2019 data since month not completed

```{r}
df_311_monthly_full <- df_311_monthly_full %>%
  filter(month <= as.Date("2019-10-01"))
```

```{r}
plot(df_311_monthly_full)
```


# Run naive OLS 

```{r}
df_311_census %>%
  group_by()
```

# Propensity score matching (PSM)

## Prep

```{r}
df_census_raw = read.csv("../data/census/census_data.tsv", sep = "\t")
```

```{r}
census_data_subset <- census_data_subset %>%
  mutate(nw_60pct = ifelse(pop_nw >= nw_threshold, 1, 0))
```

### Filter down tracts to subset with complete cases (no missing/NA values)
```{r}
census_data_subset <- census_data_subset[complete.cases(census_data_subset), ]
sum(census_data_subset$maj_nw)
nrow(census_data_subset)
```


### Filter down census_data to remaining tracts

```{r}
df_census <- df_census_raw %>%
  filter(geoid %in% city_geoids$geoid)
```

## PSM: within-city

### Prep

### Matching

### Balance checks

### Treatment effect estimation

## PSM: across cities

### Prep

### Matching

### Balance checks

### Treatment effect estimation

```{r}
nw_threshold = 0.6
census_data_subset <- census_data_subset %>%
  mutate(maj_nw = ifelse(pop_nw >= nw_threshold, 1, 0))

census_data_subset <- census_data_subset[complete.cases(census_data_subset), ]
sum(census_data_subset$maj_nw)
nrow(census_data_subset)
```

```{r}
library(MatchIt)
match_vars <- c("ed_grad", "ed_bs", "med_inc", "med_val", "med_ren")
match.out <- matchit(maj_nw ~ ed_grad + ed_bs + med_inc + med_val + med_ren, data = census_data_subset, replace = TRUE)
```

```{r}
matches <- match.out$match.matrix
```

```{r}
#install.packages("cobalt")
library(cobalt)
bal.tab(match.out, m.threshold = 0.2)
bal.plot(match.out, var.name = 'ed_grad', which = 'both')
bal.plot(match.out, var.name = 'ed_bs', which = 'both')
bal.plot(match.out, var.name = 'med_inc', which = 'both')
bal.plot(match.out, var.name = 'med_val', which = 'both')
bal.plot(match.out, var.name = 'med_ren', which = 'both')
love.plot(bal.tab(match.out, m.threshold = 0.2), stat = "mean.diffs")
```

```{r}
df_matches <- match.data(match.out)
lapply(match_vars, function(v) {
    t.test(df_matches[, v] ~ df_matches$maj_nw)
})
df_matches %>%
  group_by(maj_nw) %>%
  select(one_of(match_vars)) %>%
  summarise_all(funs(mean))
```

```{r}
# EXAMPLE, need to join w/ 311 data first
lm_model <- lm(c5r2mtsc_std ~ catholic + race_white + p5hmage +
                  I(w3income / 10^3) + p5numpla + w3momed_hsb, data = dta_m)
summary(lm_model)
```





